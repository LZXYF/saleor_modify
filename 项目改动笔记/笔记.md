# 进行商品详情页的显示

## 第一步，加入插件

起源：

​	在商品单项处，如果是多个变种属性，可以滑动显示，不至于变种太多，把详情页拉的特别长

下载插件：

 npm install react-slick --save 

插件官网：https://react-slick.neostack.com/ 

路径：家目录/saloer/saloer/static/js/variantPocker/VariantPicker.js

引入插件：

```javascript
import Slider from "react-slick";
```

使用：

```js
 render () {
     const settings = {
      dots: true,
      infinite: true,
      speed: 500,
      slidesToShow: 1,
      slidesToScroll: 1
    };
     
     ......
      return (
          <div>
            {
                  <Slider {...settings}>
                      variantAttributes.map((attribute, i) =>
                        <AttributeSelectionWidget
                          attribute={attribute}
                          handleChange={this.handleAttributeChange}
                          key={i}
                          selected={selection[attribute.pk]}
                        />
                      )
                  </Slider>
            }
      .........
      );
 }
```

修改前后箭头颜色（是用伪元素渲染的颜色，所以只能用内部式样式改变）：

```html
<style>
    .slick-prev:before, .slick-next:before
    {
        color: 'gray';
    }
</style>
```

## 第二步，修改插件样式

### 总结：

> 1. ReactJS渲染的界面，不能在html页面使用普通的js修改，可以在生命周期函数componentDidMount()中修改。也就是第一次渲染完成以后，只触发一次。
>
> 2. JQuery的append()方法，在元素最后追加子元素，如果这个子元素是页面中的某元素，那么是相当于移动，而不是复制一个新的加过去啦。
> 3. prepend($())：是jq在元素的最前面的子元素前添加新子元素。

# 加入支付宝

​	最好是结合在django项目中加入支付宝一起参考。

## 1.创建一个django的app

对于app的理解：

	> django里面用命令【python manage.py  startapp app名称】创建出来的app只是一个含有零碎文件的文件夹，就算不在settings.py中声明也可以。

我创建的app名字是alipay，和其它app一样，放在了【家目录/saleor/saleor/】下，在setting.py文件中声明了一下，saleor.alipay，其实测试了一下，不声明也可以的。

然后把支付宝需要的文件放到了名为alipay的app下，目录结构如下：

![1574924236494](images\1574924236494.png)

## 2.创建url映射

第一步，先在工程目录下的urls.py中增加对alipay url的分发：

路径：家目录/saleor/saleor/urls.py

```python
from .alipay.urls import urlpatterns as alipay_urls # 导入alipay app的映射文件
.......
non_translatable_urlpatterns = [
    url(r"^dashboard/", include((dashboard_urls, "dashboard"), namespace="dashboard")),
    url(r"^graphql/", csrf_exempt(GraphQLView.as_view(schema=schema)), name="api"),
    url(
        r"^sitemap\.xml$",
        sitemap,
        {"sitemaps": sitemaps},
        name="django.contrib.sitemaps.views.sitemap",
    ),
    url(r"^i18n/$", set_language, name="set_language"),
    url("", include("social_django.urls", namespace="social")),
    url(r"^alipay/", include(alipay_urls)),  # 加入alipay app的url映射
]
```

第二步，在alipay app中，添加支付映射，和支付回调映射,alipay app下需要手动创建一个urls.py文件：

路径：家目录/saleor/saleor/alipay/urls.py

```python
from django.conf.urls import url
from . import views

urlpatterns=[
    url(r'^alipay_result/', views.alipay_result), # 后缀不能加$，支付宝同步回调时时GET方法，会携带很多参数
    url(r'^alipay/$', views.alipay),
]
```

## 3.改写saleor支付步骤的视图文件

> 先说明saleor支付这一块的数据表关联情况：
>
> order_orderline数据表：记录i购买商品（商品名称，购买数量等等），每一件商品产生一条记录，与order_order表关联，多对一。
>
> order_order数据表：订单数据表，一次订单产生一次记录，一次订单可以买多个商品。
>
> payment_payment数据表：记录支付情况，与order_order数据表一对一关联，支付没有完成是【charge_status=not-charged】【captured_amount=0.0】，支付完成以后是【charge_status=fully-charged】【captured_amount=支付的钱数】。
>
> 

用户视角：

![1574924945960](images\1574924945960.png)

上面的视角中，当用户点击了【进行支付】按钮，order_order和payment_payment数据表中就已经创建了记录，不过paymeny_payment数据表中是未支付的状态。

用户视角：

![1574925869768](images\1574925869768.png)

上面的视角是经过了下面的view方法跳转过来的，这里利用form表单的提交按钮点击以后会刷新页面重新请求页面，所以此处的form没有【action】属性，也就是说只要点击浅蓝色按钮，就会执行下面的view函数：

路径：家目录/saleor/saleor/order/views.py

```python
@check_order_status
def start_payment(request, order, gateway):
    payment_gateway, gateway_config = get_payment_gateway(gateway)
    connection_params = gateway_config.connection_params
    extra_data = {"customer_user_agent": request.META.get("HTTP_USER_AGENT")}
    i = 0;
    with transaction.atomic():
...........
```

修改这个函数成：

```python
 payment_info = create_payment_information(payment)
        form = payment_gateway.create_form(
            data=request.POST or None,
            payment_information=payment_info,
            connection_params=connection_params,
        )
        if form.is_valid():
         	# 修改区域------------------------------
            try:
                print("验证完成的    的fromtoken:::" , form.get_payment_token())
                request.session['total'] = str(Decimal(payment.total).quantize(Decimal('0.0')))
                request.session['order_id'] = str(order.id)
                request.session['token'] = order.token
                return redirect("/alipay/alipay/")
            except Exception as exc:
                form.add_error(None, str(exc))
			# 修改区域-----------------------------
    client_token = payment_gateway.get_client_token(config=gateway_config)
    ctx = {
        "form": form,
        "payment": payment,
        "client_token": client_token,
        "order": order,
    }
```

### 目的：

> 本来是，支付完成以后，先修改数据表为支付过状态，然后重定向到saleor的支付成功页面上，但是我在这里做了修改，先直接让它重定向到支付宝支付页面，只有完成支付以后，我才会对数据库中的支付状态进行改变，也就是说是在支付宝的异步回调中修改后台业务逻辑。但是重定向以后，有些必要的数据又会得不到，所以把必要数据暂存到session中去。
>
> total：需支付总钱数
>
> token：为了支付完成以后能返回到saleor的支付成功页面，而需要的参数。
>
> order_id：为了在支付宝的异步回调中，从数据库中获取到指定记录并修改。

## 4.在settings.py中加入支付宝配置信息

直接在settings.py文件的最后加上如下：

```python
# 支付宝参数配置
class AliPayConfig(object):
    # 正式启用时需要重新配置app_id ，merchant_private_key_path ，alipay_public_key_path
    app_id = "2016092700607535"  # APPID  沙箱应用

    # 支付完成后支付宝向这里发送一个post请求，如果识别为局域网ip，支付宝找不到，alipay_result（）接受不到这个请求
    notify_url = "http://211.64.38.90:8008/alipay/alipay_result/"

    # 支付完成后跳转的地址
    return_url = "http://211.64.38.90:8008/alipay/alipay_result/"
    # 应用私钥
    merchant_private_key_path = os.path.join(PROJECT_ROOT, "saleor/alipay/keys/app_private_key.pem")
    # 支付宝公钥
    alipay_public_key_path = os.path.join(PROJECT_ROOT, "saleor/alipay/keys/alipay_public_key.pem")  # 验证支付宝回传消息使用
```

## 5.alipay app的支付请求函数

```python
..........
# 账户充值（支付宝）视图函数
def alipay(request):
    token = request.session['token']
    del request.session['token']
    order_id = str(request.session['order_id'])
    del request.session['order_id']
    total = round(float(request.session['total']),2)
    del request.session['total']
  #  '''根据当前用户的配置生成url，并跳转'''
    alipay = get_ali_object()
    # 生成支付的url
    query_params = alipay.direct_pay(
        subject="充值到XXX",  # 订单名称
        out_trade_no=order_id + "-" +token,  # 用户购买商品订单号（每次不一样）
        total_amount=total,  # 交易金额
        token_str=token
    )
    # 支付url
    print(alipay.app_private_key)
    pay_url = "https://openapi.alipaydev.com/gateway.do?{0}".format(query_params)  # 支付宝网关地址（沙箱应用）
    return redirect(pay_url)
```

## 6.回调请求函数

```python
# 导入用到的函数等
from ..payment.utils import (gateway_process_payment)
from ..payment.models import Payment
from ..order.models import Order

# 支付成功后回调函数（支付宝）
def alipay_result(request):
    alipay = get_ali_object()
    if request.method == "POST":  # POST方法后台回调，只能在外网服务器测试
        # 检测是否支付成功
        # 去请求体中获取所有返回的参数：状态/订单号
        post_dict = request.POST.dict()

        sign = post_dict.pop('sign', None)
        money = post_dict['total_amount']
        status = alipay.verify(post_dict, sign)  # 验签

        if status:
                # '''
                # 支付成功后业务逻辑，这里有通知才是真正的完成了支付，return_url可以理解为理论上的成功，这个才是支付宝真的成功发送的请求
                # '''
            return HttpResponse('success')
        else:
                # '''
                # 支付失败后业务逻辑
                # '''
            return HttpResponse('')

    else:   # GET请求 前台回调
        params = request.GET.dict()
        sign = params.pop('sign', None)
        passback_params = params["out_trade_no"]
        token = passback_params[passback_params.index("-")+1:]
        order_id = passback_params[:passback_params.index("-")]
        payment = Payment.objects.get(order_id=order_id)
        order = Order.objects.get(pk=order_id)
	   status = alipay.verify(params, sign)  # 验签
        if status:
                try:
                    gateway_process_payment(
                        payment=payment, payment_token=token
                    )
                except Exception as exc:
                    print(exc)
                else:
                    if order.is_fully_paid():
                        return redirect("order:payment-success", token=token)
                    return redirect(order.get_absolute_url())
        else:
            return HttpResponse('支付失败')
```

目前所有操作都是在同步回调函数中实现，部署到公网地址上以后再将业务逻辑转到异步回调部分中去，也就是method == 'POST'部分中。

​		对于gateway_process_payment()方法，之前是在try块中，现在我们将它拿出来，为了提高代码的可靠性，可以将此方法放到事务中，这样发生异常数据回滚，也不会造成后台数据的错误。

